# script to generate K-core data for figure 1. 
# George Chacko 10/18/2021
# Input is manually edited file from Eleanor Wedell's pdf
# https://unofficialwarnowlab.slack.com/archives/C02467U3JQ0/p1634574427226000

rm(list=ls())
library(data.table); library(ggplot2); library(grid)

# read input file
setwd('~/repos/clustering_manuscripts/discovery')
x <- fread('k_core_cluster_sizes.csv')
# add node_coverage column 'nc' that expresses the size of K-core output
# as a percentage of total node count ()14,695,475)
x[,nc:=round(100*sum(V2)/(x[V1==1][,sum(V2)]),2),by="V1"]

#Select largest component in each k-value
y <- x[,.(csize=max(V2)),by='V1']
break_vec <- seq(0,60,by=5)

# note that for k=1 and k=2 there are multiple components
# k=1 has 13 x[V1==1][,V2]
# k=2 has 2 x[V1==2][,V2]

pdf('fig1_kcore.pdf')
qplot(as.factor(V1),nc,data=x,size=V2) + theme_bw() + 
geom_jitter(width=0.02) + labs(x=("K"),y=("% node_coverage")) + 
theme(legend.position = "none") + theme(text = element_text(size = 20)) 
dev.off()

p1 = qplot(V1,csize/1000000,data=y[V1%%5==0],xlab="k",ylab="k-core size (millions)") +
theme_bw() + scale_x_continuous("k",breaks=break_vec) + theme(text = element_text(size = 20)) 

# read in KC data with modularity values generated by kc_process.R
df_kc <- fread('~/repos/clustering_manuscripts/discovery/df_kc.csv.txt')

k_vec <- readr::parse_number(df_kc$condition)
df_kc <- cbind(df_kc,k=k_vec)
temp <- df_kc[,max(N),by='k']

plot_df <- merge(temp, df_kc, by.x=c('k','V1'),by.y=c('k','N'))
plot_df[V4 >0, mod:='+ve']
plot_df[V4 <=0, mod:='-ve']


p2 <- qplot(log10(k),log10(V1),data=plot_df,color=mod,xlab='log10(k)',ylab='log10(k-core size)') + geom_point(size=4) +
theme_bw() + theme(text = element_text(size = 18))  

# create viewport setting
vp <- viewport(width = 0.5, height = 0.5, x = 0.4, y = 0.4)

pdf('fig1_inset.pdf')
print(p2)
print(p1,vp=vp)
dev.off()
