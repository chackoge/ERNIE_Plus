import datetime
from timeit import default_timer

import click
import numpy as np
import networkit as nk

from python_scripts.utils.utils import file_to_dict,write_new_sorted_cluster_dict


@click.command()
@click.option("--previous-clustering", required=True, type=click.Path(exists=True), help="Clustering from previous iteration")
@click.option("--current-clustering", required=True, type=click.Path(exists=True), help="Clustering from current iteration")
@click.option("--iteration-number", required=True, type=int, help="Current iteration number that is only used for naming the output file")
@click.option("--output-prefix", required=True, type=click.Path(), help="Output file prefix")
def generate_save_for_later(previous_clustering, current_clustering, iteration_number, output_prefix):
    '''This is the main function that will take in a clustering and another clustering
    that was generated by running graclus on every cluster and only saving the kmp-valid clusters,
    then it will output clusters from the previous clustering that did not get split into
    any subclusters in the current clustering
    '''
    previous_cluster_to_id_dict = file_to_dict(previous_clustering)["cluster_to_id_dict"]
    previous_id_to_cluster_dict = file_to_dict(previous_clustering)["id_to_cluster_dict"]
    current_cluster_to_id_dict = file_to_dict(current_clustering)["cluster_to_id_dict"]
    current_id_to_cluster_dict = file_to_dict(current_clustering)["id_to_cluster_dict"]
    save_for_later_cluster_to_id_dict = file_to_dict(previous_clustering)["cluster_to_id_dict"]
    already_popped_set = set()
    for current_cluster,current_cluster_member_arr in current_cluster_to_id_dict.items():
        # get the first node as a representative node
        representative_node = current_cluster_member_arr[0]
        print(f"representative_node: {representative_node}")
        kosher_marked_cluster_id = previous_id_to_cluster_dict[representative_node][0]
        print(f"kosher_marked_cluster_id: {kosher_marked_cluster_id}")
        if(kosher_marked_cluster_id not in already_popped_set):
            save_for_later_cluster_to_id_dict.pop(kosher_marked_cluster_id)
            already_popped_set.add(kosher_marked_cluster_id)

    write_new_sorted_cluster_dict(save_for_later_cluster_to_id_dict, [], f"{output_prefix}/save_for_later_{iteration_number}")


if __name__ == "__main__":
    generate_save_for_later()
